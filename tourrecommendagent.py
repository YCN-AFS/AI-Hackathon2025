# -*- coding: utf-8 -*-
"""Bản sao của TourRecommendAgent.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ehRQT0UNiTzsWObHRymh8TKWs4LcNf4Q
"""

# Commented out IPython magic to ensure Python compatibility.
# %%capture --no-stderr
# %pip install -U langgraph langchain-community langchain-anthropic tavily-python pandas

!pip install --upgrade --quiet langchain-huggingface text-generation transformers google-search-results numexpr langchainhub sentencepiece jinja2 bitsandbytes accelerate

!pip install -qU langchain-community faiss-cpu

!pip install --quiet langchain_experimental

!pip install -qU langchain-google-genai

import os
# import shutil
# import sqlite3

import pandas as pd
import requests
from langchain_huggingface import ChatHuggingFace, HuggingFaceEndpoint

from typing import Annotated, Literal, Optional
from typing_extensions import TypedDict
from langgraph.graph.message import AnyMessage, add_messages
from pydantic import BaseModel, Field
from typing import List
from langgraph.types import interrupt

import uuid
from typing import TypedDict, Optional

from langgraph.graph import StateGraph
from langgraph.constants import START, END
from langgraph.types import interrupt, Command
from langgraph.checkpoint.memory import MemorySaver
from langchain_core.runnables import Runnable, RunnableConfig, RunnableLambda
from langchain_core.prompts import ChatPromptTemplate
from IPython.display import Image, display
import getpass
import os
from langgraph.prebuilt import ToolNode, tools_condition
from langchain_core.messages import ToolMessage, HumanMessage, SystemMessage
from typing import Callable
import requests
from datetime import datetime, timedelta
from langchain_google_genai import ChatGoogleGenerativeAI
from langchain_community.tools.tavily_search import TavilySearchResults
from langchain_core.tools import tool
import json

"""# Chat Model

- **Remote**
"""

# if "GOOGLE_API_KEY" not in os.environ:
#     os.environ["GOOGLE_API_KEY"] = getpass.getpass("Enter your Google AI API key: ")

os.environ["GOOGLE_API_KEY"] = "AIzaSyBt4n2O89U7XKNM2LDwa0DSP5MI80yEwpA"

# os.environ["GOOGLE_API_KEY"] = "AIzaSyD8Nzvo0C3HNqFQ05KUlnt3VxF2AMe_f6A"

# gemini-1.5-flash, gemini-2.0-flash-thinking-exp

llm = ChatGoogleGenerativeAI(
    model="gemini-1.5-flash",
    temperature=0.5,
    max_tokens=None,
    timeout=None,
    max_retries=2,
    context_window = 4096, # Context Window specifies how many tokens to use as context for the LLM
    max_new_tokens = 4096 # Max New Tokens specifies how many new tokens to generate for the LLM
    # other params...
)

# llm = HuggingFaceEndpoint(
#     repo_id="Qwen/Qwen2.5-72B-Instruct",
#     temperature=0.5,
#     max_tokens=None,
#     timeout=None,
#     max_retries=2,
#     context_window = 4096, # Context Window specifies how many tokens to use as context for the LLM
#     max_new_tokens = 4096 # Max New Tokens specifies how many new tokens to generate for the LLM
#     # other params...
# )

# llm = ChatHuggingFace(llm=llm)

messages = [
    (
        "system",
        "Bạn là trợ thủ đắc lực nha."
        "Hãy trả lời bằng tiếng việt"
    ),
    ("human", "Xin chào, bạn nói được tiếng việt tốt không?"),
]
ai_msg = llm.invoke(messages)
ai_msg

"""# Define State"""

def update_dialog_stack(container: list[str], what: Optional[str]) -> list[str]:
    """Push or pop the state."""
    if what is None:
        return container
    if what == "pop":
        return container[:-1]
    return container + [what]


class Preferences(BaseModel):
    name: Optional[str] = Field("Vô Danh", description="Tên người dùng")
    number_member: Optional[str] = Field("2", description="Tổng số thành viên trong nhóm")
    total_expense: Optional[str] = Field("2 triệu", description="Chi phí tổng mà người dùng có thể bỏ ra cho chuyến đi")

    # buy_souvenir: Optional[str] = Field("Có", description="Có muốn mua quà lưu niệm không? (Có /Không)")
    # allergy: Optional[str] = Field("Không", description="Danh sách các dị ứng (ví dụ: đậu phộng, hải sản)")
    # illness: Optional[str] = Field("Không", description="Danh sách bệnh lý (ví dụ: tiểu đường, cao huyết áp)")
    # food: Optional[str] = Field("Không", description="Chế độ ăn uống: ăn chay hoặc ăn mặn")
    # get_up_time: Optional[str] = Field("7:00", description="Thời gian thức dậy mong muốn (định dạng HH:MM)")
    # number_meal: Optional[str] = Field("3", description="Số bữa ăn trong một ngày")
    # take_a_nap: Optional[str] = Field("Không", description="Có ngủ trưa không? (Có /Không)")
    # sleeping_time: Optional[str] = Field("12:00", description="Thời gian đi ngủ mong muốn (định dạng HH:MM)")
    # start_day: Optional[str] = Field("2 triệu", description="Chi phí tổng mà người dùng có thể bỏ ra cho chuyến đi")


class State(TypedDict):
    messages: Annotated[list[AnyMessage], add_messages]
    preferences: Preferences
    Recommended_Tour: dict


    # user_info: str

    dialog_state: Annotated[
        list[
            Literal[
                "Primary_Agent",
                "Accommodation_Agent",
                "Destination_Agent",
                "Food_Agent",
                "Transaction_Agent"
            ]
        ],
        update_dialog_stack,
    ]

"""# Primary Agent

## Tool
"""

def asking_preference(state: State):
    print("""
            Trước tiên, tớ muốn hỏi bạn về một số thứ để hiểu rõ hơn về bạn. Nếu bỏ qua hãy nhấn enter
          """)

    answer0 = input(
        """
        Bạn tên gì?
        """
    )

    answer1 = input(
        """
        Số thành viên trong nhóm?
        (Mặc định là 2)
        """
    ) or "2"


    answer2 = input(
        """
        Tổng chi phí bạn bỏ ra cho cả một chuyến đi là bao nhiêu?
        (Mặc định là 3.000.000)
        """
    ) or "3.000.000"

    # answer3 = input(
    #     """
    #     Trong nhóm có ai bị dị ứng về cái gì không?
    #     Ví dụ: hải sản, đậu phộng, ...
    #     (Mặc định là Không)
    #     """
    # ) or "Không"

    # answer4 = input(
    #     """
    #     Trong nhóm có ai bị mắc bệnh gì không?
    #     Ví dụ: tim, huyết áp cao, ...
    #     (Mặc định là Không)
    #     """
    # ) or "Không"

    # answer5 = input(
    #     """
    #     Nhóm mình thích ăn gì?
    #     Ví dụ: hải sản, chay, thịt nướng, ...
    #     (Mặc định là Không)
    #     """
    # ) or "Mặn"

    # answer6 = input(
    #     """
    #     Nhóm mình thường thức dậy lúc mấy giờ?
    #     (Mặc định là 7:00)
    #     """
    # ) or "7:00"

    # answer7 = input(
    #     """
    #     Nhóm mình ăn bao nhiêu bữa trong ngày?
    #     (Mặc định là 3)
    #     """
    # ) or "3"

    # answer8 = input(
    #     """
    #     Nhóm mình có muốn ngủ trưa không?
    #     (Mặc định là Không)
    #     """
    # ) or "Không"

    # answer9 = input(
    #     """
    #     Nhóm mình thường ngủ vào mấy giờ?
    #     (Mặc định là 12:00)
    #     """
    # ) or "12:00"

    # answer10 = input(
    #     """
    #     Nhóm mình có muốn mua quà lưu niệm không?
    #     (Mặc định là Có)
    #     """
    # ) or "Có"


    return {
        "preferences": Preferences(
            name=answer0,
            number_member=answer1,
            total_expense=answer2,
            # allergy=answer3,
            # illness=answer4,
            # food=answer5,
            # get_up_time=answer6,
            # number_meal=answer7,
            # take_a_nap=answer8,
            # sleeping_time=answer9,
            # buy_souvenir=answer10
        )
    }

class ToAccommodation_Agent(BaseModel):
    """Chuyển cuộc hội thoại cho Accommodation_Agent, người cho chuyên môn về nơi ở (khách sạn, homestay, resort...) ở Việt Nam
     dựa trên sở thích, ngân sách và nhu cầu của người dùng."""

    main_location: str = Field(
        ...,
        description="Địa điểm chính mà người dùng muốn đặt nơi ở",
        example="Nha Trang"
    )
    expense: str = Field(
        ...,
        description="Số tiền mà người dùng có thể bỏ ra thuê nơi ở",
        example="Dưới 200.000 VNĐ"
    )
    option: str = Field(
        ...,
        description="Những lưu ý, mong muốn, yêu cầu phụ của người dùng liên quan đến địa điểm chính của nơi ở",
        example="Gần biển"
    )

class ToDestination_Agent(BaseModel):
    """Chuyển cuộc hội thoại cho Destination_Agent, người cho chuyên môn về địa điểm nổi tiếng ở Việt Nam (như Đà Lạt, Đà Nẵng, ...)
    dựa trên sở thích, ngân sách và nhu cầu của người dùng."""

    main_location: str = Field(
        ...,
        description="Địa điểm du lịch chính mà người dùng muốn đến",
        example="Sài Gòn"
    )
    expense: str = Field(
        ...,
        description="Số tiền mà người dùng có thể bỏ ra để đến nơi đó",
        example="Dưới 2000.000 VNĐ"
    )
    option: str = Field(
        ...,
        description="Những lưu ý, mong muốn, yêu cầu phụ của người dùng liên quan đến địa điểm du lịch chính",
        example="Dành cho giới trẻ"
    )

class ToFood_Agent(BaseModel):
    """Chuyển cuộc hội thoại cho Food_Agent, người chuyên tư vấn về các địa điểm ẩm thực (như nhà hàng, quán ăn, vỉa hè) ở Việt Nam
    dựa trên sở thích, ngân sách và nhu cầu của người dùng."""

    main_location: str = Field(
        ...,
        description="Khu vực hoặc địa điểm mà người dùng muốn tìm kiếm các địa điểm ăn uống",
        example="Hà Nội"
    )
    expense: str = Field(
        ...,
        description="Số tiền mà người dùng dự định chi cho bữa ăn hoặc trải nghiệm ẩm thực",
        example="Dưới 500.000 VNĐ"
    )
    allergy: str = Field(
        ...,
        description="Danh sách các món ăn dị ứng",
        example="Đậu phộng, hải sản"
    )
    option: str = Field(
        ...,
        description="Những lưu ý, mong muốn, yêu cầu phụ của người dùng liên quan đến trải nghiệm ẩm thực",
        example="Có đồ ăn chay"
    )

class ToTransaction_Agent(BaseModel):
    """Chuyển cuộc hội thoại cho Transaction_Agent, người chuyên thực hiện các vấn đề liên quan đến giao dịch.
    Khi người dùng yêu cầu bất cứ gì về giao dịch, phải nhờ sự giúp đỡ Transaction_Agent.\n
    **Không được tự ý trả lời**"""

"""## Prompt"""

def format_preferences(preferences: Preferences) -> str:
    return (
        f"- Tên người dùng (đại diện cho nhóm): {preferences.name}\n"
        f"- Số thành viên trong nhóm: {preferences.number_member}\n"
        f"- Tổng số tiền mà nhóm có thể bỏ ra cho cả một chuyến đi: {preferences.total_expense}\n"
        # f"- Dị ứng: {preferences.allergy}\n"
        # f"- Bệnh lý: {preferences.illness}\n"
        # f"- Loại món ăn ưa thích {preferences.food}\n"
        # f"- Thời gian thức dậy: {preferences.get_up_time}\n"
        # f"- Số bữa ăn trong 1 ngày: {preferences.number_meal}\n"
        # f"- Thói quen ngủ trưa: {preferences.take_a_nap} ngủ trưa\n"
        # f"- Giờ đi ngủ: {preferences.sleeping_time}\n"
        # f"- Có mua quà lưu niệm không? {preferences.buy_souvenir} mua\n"
    )

def create_prompt(preferences: Preferences):
    preferences_text = format_preferences(preferences)

    agent_prompt = ChatPromptTemplate.from_messages(
        [
            (
                "system",
                "Bạn là một trợ lý du lịch thông minh, chuyên giúp người dùng lên lịch trình và sắp xếp thời gian chuyến đi.\n"
                "📌 Chức năng chính của bạn là điều phối cuộc hội thoại cho các Agent chuyên môn khác dựa trên câu hỏi của người dùng.\n"
                "❌ Bạn không tư vấn về lịch trình, nơi ở, phương tiện di chuyển, ăn uống hay các hoạt động khác.\n\n"

                "💡 **Hướng dẫn quan trọng chung:**\n"
                "- Trả lời ngắn gọn, dễ hiểu bằng tiếng Việt (người dùng không hiểu các ngôn ngữ khác).\n"
                "- Xưng hô thân thiện: 'tôi' với 'bạn'.\n"
                "- Nếu có công cụ phù hợp, hãy sử dụng công cụ đó để có thêm thông tin phù hợp, trước khi trả lời câu hỏi của người dùng.\n"
                "- Sau khi trả lời xong câu hỏi, hãy hỏi: \"Tôi có thể giúp gì thêm cho bạn?\"\n"
                "- Nếu người dùng hỏi ngoài chuyên môn và không có Agent nào phù hợp, hãy trả lời: \"Xin lỗi tôi chưa thể giúp đỡ bạn về vấn đề này.\"\n\n"

                "💡 **Hướng dẫn quan trọng về việc đưa gợi ý và đặt câu hỏi:**\n"
                "- Chỉ đưa ra gợi ý khi người dùng hỏi, **không tự đề xuất trước!**\n"
                "- Chỉ hỏi khi đang trao đổi về một vấn đề cụ thể, **không tự ý hỏi trước!**\n"
                "- Nếu thông tin chưa rõ, hãy hỏi lại một cách cụ thể thay vì đoán. Nhưng không được hỏi quá nhiều vì nó làm trải nghiệm người dùng tệ đi.\n"
                "- Mỗi lần chỉ hỏi 1 khía cạnh, **không gộp nhiều câu hỏi lại cùng lúc**.\n\n"

                "💡 **Hướng dẫn quan trọng về việc gọi các Agent khác:**\n"
                "- Nếu người dùng cần hỗ trợ về **nơi ở, di chuyển, ăn uống, địa điểm du lịch hay các hoạt động khác**, hãy chuyển hội thoại cho Agent phù hợp.\n"
                "- Trước khi gọi các Agent khác để trợ giúp, **phải** hỏi những thông tin cần thiết theo Schema của Agent đó.\n"
                "- ❌ **Không hỏi thông tin ngoài Schema của Agent đó**.\n"
                "- 📌 Hãy nhớ chỉ hỏi trong pham vị Schema của Agent, nếu đủ thông tin thì hãy nhờ sự trợ giúp luôn. Vì nếu hỏi quá nhiều sẽ làm trải nghiệm của người dùng tệ đi.\n"
                "- Không đề cập đến việc nhờ Agent nào giúp đỡ và việc bạn có nhờ hay không, chỉ tập trung vào việc hỏi thông tin cần thiết.\n"
                "- Không hỏi lại những thông tin đã được cung cấp.\n\n"

                "💡 **Hướng dẫn quan trọng về việc gọi các Agent mà Schema không có key:**\n"
                "- 📌Khi người dùng yêu cầu hay hỏi các công việc liên quan, phải chuyển cuộc hội thoại cho những Agent này ngay lập tức.\n"
                "- ❌Không được tự ý trả lời.\n"
                "- Ví dụ: Transaction_Agent, thì tất cả câu hỏi liên quan đều đưa về giao dịch, thì ngay lập tức nhờ sự giúp đỡ của Transaction_Agent.\n\n"


                "📌 **Thông tin nhóm du lịch:**\n"
                f"{preferences_text}\n\n"

                "🚀 Hãy giúp người dùng có một chuyến đi tuyệt vời!"
            ), ("placeholder", "{messages}"),
        ]
    )

    return agent_prompt

"""## Agent"""

Primary_Agent_tools = [ToAccommodation_Agent,
                       ToDestination_Agent,
                       ToFood_Agent,
                       ToTransaction_Agent]

def Primary_Agent(state: State):
    prompt = create_prompt(state["preferences"])
    # print(prompt)
    runnable = prompt | llm.bind_tools(Primary_Agent_tools)

    while True:
        result = runnable.invoke(state)

        if not result.tool_calls and (
            not result.content
            or isinstance(result.content, list)
            and not result.content[0].get("text")
        ):
            messages = state["messages"] + [("user", "Respond with a real output.")]
            state = {**state, "messages": messages}
        else:
            break

    state_out = {"messages": result}
    return state_out

"""# Accommodation_Agent

## Tool
"""

os.environ["TAVILY_API_KEY"] = "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"

class SearchInput(BaseModel):
    request: str = Field(description="Những câu hỏi, thông tin cần tìm kiếm online", example="Những địa điểm ăn uống ở Sài Gòn")

@tool("search_tool", args_schema=SearchInput)
def search_tool(request):
    """Đây là công cụ tìm kiếm online. Đây không phải là placeholder. Công cụ này search online rất hiệu quả.
      Hãy dùng khi bạn cần có thêm thông tin mà chưa biết."""

    search_results = TavilySearchResults(max_results=2).invoke(request)
    return search_results

search_tool.invoke("Những địa điểm ăn uống ở Sài Gòn")

class CompleteOrEscalate(BaseModel):
    """
    Một công cụ để đánh dấu nhiệm vụ hiện tại đã hoàn thành và/hoặc chuyển giao quyền kiểm soát cuộc đối thoại
    cho Primary Agent, người có thể điều chỉnh lại hướng cuộc đối thoại dựa trên nhu cầu của người dùng.
    """

    complete: bool = Field(
        ...,
        description="Vấn đề của người dùng đã được giải quyết xong chưa? Rồi thì True, Chưa thì False",
        example="False"
      )
    reason: str = Field(
        ...,
        description="Nguyên nhân tại sao đưa cuộc đối thoại về lại Primary Agent",
        example="Người dùng hỏi về chủ đề khác ngoài chuyên môn"
      )

"""## Prompt"""

def format_preferences(preferences: Preferences) -> str:
    return (
        f"- Tên người dùng (đại diện cho nhóm): {preferences.name}\n"
        f"- Số thành viên trong nhóm: {preferences.number_member}\n"
        f"- Tổng số tiền mà nhóm có thể bỏ ra cho cả một chuyến đi: {preferences.total_expense}\n"
        # f"- Dị ứng: {preferences.allergy}\n"
        # f"- Bệnh lý: {preferences.illness}\n"
        # f"- Loại món ăn ưa thích {preferences.food}\n"
        # f"- Thời gian thức dậy: {preferences.get_up_time}\n"
        # f"- Số bữa ăn trong 1 ngày: {preferences.number_meal}\n"
        # f"- Thói quen ngủ trưa: {preferences.take_a_nap} ngủ trưa\n"
        # f"- Giờ đi ngủ: {preferences.sleeping_time}\n"
        # f"- Có mua quà lưu niệm không? {preferences.buy_souvenir} mua\n"
    )

def create_accommodation_prompt(preferences: Preferences):
    preferences_text = format_preferences(preferences)

    agent_prompt = ChatPromptTemplate.from_messages(
        [
            (
              "system",
              "Bạn là một trợ lý du lịch thông minh, chuyên tư vấn tour theo sở thích của người dùng.\n"
              "📌 Chuyên môn của bạn là tư vấn về nơi ở (khách sạn, homestay, resort...) dựa trên sở thích, ngân sách và nhu cầu của người dùng.\n"
              "❌ Không tư vấn về lịch trình, phương tiện di chuyển, ăn uống hay các hoạt động khác; nhiệm vụ của bạn chỉ tập trung vào gợi ý nơi ở.\n\n"

              "💡 **Hướng dẫn quan trọng chung:**\n"
              "- Trả lời ngắn gọn, dễ hiểu bằng tiếng Việt. Hãy nhớ người dùng không hiểu các ngôn ngữ khác.\n"
              "- Chỉ gợi ý khi người dùng hỏi, đừng tự đề xuất trước!\n"
              "- Xưng hô thân thiện: 'tôi' với 'bạn'.\n"
              "- Nếu có công cụ phù hợp, hãy sử dụng công cụ đó để có thêm thông tin phù hợp, trước khi trả lời câu hỏi của người dùng.\n"
              "- Không được tạo ra các công cụ hoặc chức năng không hợp lệ.\n\n"

              "💡 **Hướng dẫn quan trọng về việc gọi các Agent khác:**\n"
              "- Nếu thông tin người dùng cung cấp chưa đủ (vd: chưa nói rõ số người, ngân sách, loại hình nơi ở mong muốn...), có thể hỏi trực tiếp người dùng.\n"
              "- Nếu người dùng hỏi về thứ ngoài chuyên môn (vd: vé máy bay, tour trọn gói...).Hãy dùng 'CompleteOrEscalate' tool để đưa cuộc đối thoại về lại Primary Agent.\n\n"

              "💡 **Hướng dẫn quan trọng về việc dùng 'CompleteOrEscalate':**\n"
                "- Phải nói rõ là yêu cầu hay câu hỏi đã được giải quyết chưa (Complete key).\n"
                "- Phải nói rõ nguyên nhân lại chuyển hội thoại cho Primary Agent (Reason key).\n\n"

              "💡 **Hướng dẫn quan trọng về việc tìm kiếm online:**\n"
              "- Hãy dùng khi bạn cần có thêm thông tin mà chưa biết.\n"
              "📌 Bạn có khả năng search online bằng công cụ tìm kiếm online 'search_tool'. **Hãy sử dụng (tạo tool_call) khi cần**.\n"
              "❌ Không bao giờ được nói rằng mình không có khả năng search online.\n\n"

              "\n\n📌 **Thông tin nhóm du lịch:**\n"
              f"{preferences_text}"

              "\n🚀 Hãy giúp người dùng có những chỗ ở tuyệt vời tuyệt vời!"
            ),("placeholder", "{messages}"),
        ]
    )

    return agent_prompt

"""## Agent"""

Accommodation_Agent_tools = [search_tool, CompleteOrEscalate]

def Accommodation_Agent(state: State):
    prompt = create_accommodation_prompt(state["preferences"])
    # print(prompt)
    runnable = prompt | llm.bind_tools(Accommodation_Agent_tools)

    while True:
        result = runnable.invoke(state)

        if not result.tool_calls and (
            not result.content
            or isinstance(result.content, list)
            and not result.content[0].get("text")
        ):
            messages = state["messages"] + [("user", "Respond with a real output.")]
            state = {**state, "messages": messages}
        else:
            break

    state_out = {"messages": result}
    return state_out

"""# Destination Agent

## Prompt
"""

def format_preferences_destination(preferences: Preferences) -> str:
    return (
        f"- Tên người dùng (đại diện cho nhóm): {preferences.name}\n"
        f"- Số thành viên trong nhóm: {preferences.number_member}\n"
        f"- Tổng số tiền mà nhóm có thể bỏ ra cho cả một chuyến đi: {preferences.total_expense}\n"
    )

def create_destination_prompt(preferences: Preferences):
    preferences_text = format_preferences_destination(preferences)
    # Đây là prompt chuyên về địa điểm du lịch nổi tiếng
    agent_prompt = ChatPromptTemplate.from_messages(
        [
            (
                "system",
                "Bạn là một trợ lý du lịch thông minh, chuyên tư vấn về các địa điểm du lịch nổi tiếng.\n"
                "📌 Chuyên môn của bạn là gợi ý những địa điểm du lịch hấp dẫn, nổi bật và có uy tín dựa trên thông tin lịch sử, danh tiếng và trải nghiệm của du khách.\n"
                "❌ Bạn không tư vấn về nơi ở, phương tiện di chuyển, ẩm thực hay các hoạt động khác; nhiệm vụ của bạn chỉ tập trung vào gợi ý điểm đến du lịch.\n\n"

                "💡 **Hướng dẫn quan trọng chung:**\n"
                "- Trả lời ngắn gọn, dễ hiểu bằng tiếng Việt. Hãy nhớ người dùng không hiểu các ngôn ngữ khác.\n"
                "- Chỉ gợi ý khi người dùng hỏi, đừng tự đề xuất trước!\n"
                "- Xưng hô thân thiện: 'tôi' với 'bạn'.\n"
                "- Nếu có công cụ phù hợp, hãy sử dụng công cụ đó để có thêm thông tin phù hợp, trước khi trả lời câu hỏi của người dùng.\n"
                "- Không được tạo ra các công cụ hoặc chức năng không hợp lệ.\n\n"

                "💡 **Hướng dẫn quan trọng về việc gọi các Agent khác:**\n"
                "- Nếu thông tin người dùng cung cấp chưa đủ (vd: chưa nói rõ số người, ngân sách, loại hình nơi ở mong muốn...), có thể hỏi trực tiếp người dùng.\n"
                "- Nếu người dùng hỏi về thứ ngoài chuyên môn (vd: vé máy bay, tour trọn gói...).Hãy dùng 'CompleteOrEscalate' tool để đưa cuộc đối thoại về lại Primary Agent.\n\n"

                "💡 **Hướng dẫn quan trọng về việc dùng 'CompleteOrEscalate':**\n"
                "- Phải nói rõ là yêu cầu hay câu hỏi đã được giải quyết chưa (Complete key).\n"
                "- Phải nói rõ nguyên nhân lại chuyển hội thoại cho Primary Agent (Reason key).\n\n"

                "💡 **Hướng dẫn quan trọng về việc tìm kiếm online:**\n"
                "- Hãy dùng khi bạn cần có thêm thông tin mà chưa biết.\n"
                "📌 Bạn có khả năng search online bằng công cụ tìm kiếm online 'search_tool'. **Hãy sử dụng (tạo tool_call) khi cần**.\n"
                "❌ Không bao giờ được nói rằng mình không có khả năng search online.\n\n"

                "📌 **Thông tin nhóm du lịch:**\n"
                f"{preferences_text}\n\n"

                "\n🚀 Hãy giúp người dùng có những địa điểm du lịch tuyệt vời!"
            ),
            ("placeholder", "{messages}"),
        ]
    )
    return agent_prompt

"""## Agent"""

Destination_Agent_tools = [search_tool, CompleteOrEscalate]

def Destination_Agent(state: State):
    prompt = create_destination_prompt(state["preferences"])
    # print(prompt)
    runnable = prompt | llm.bind_tools(Destination_Agent_tools)

    while True:
        result = runnable.invoke(state)

        if not result.tool_calls and (
            not result.content
            or isinstance(result.content, list)
            and not result.content[0].get("text")
        ):
            messages = state["messages"] + [("user", "Respond with a real output.")]
            state = {**state, "messages": messages}
        else:
            break

    state_out = {"messages": result}
    return state_out

"""# Food Agent

## Prompt
"""

def format_preferences_destination(preferences: Preferences) -> str:
    return (
        f"- Tên người dùng (đại diện cho nhóm): {preferences.name}\n"
        f"- Số thành viên trong nhóm: {preferences.number_member}\n"
        f"- Tổng số tiền mà nhóm có thể bỏ ra cho cả một chuyến đi: {preferences.total_expense}\n"
    )

def create_food_prompt(preferences: Preferences):
    preferences_text = format_preferences_destination(preferences)
    # Đây là prompt chuyên về địa điểm du lịch nổi tiếng
    agent_prompt = ChatPromptTemplate.from_messages(
        [
            (
                "system",
                "Bạn là một trợ lý du lịch thông minh, chuyên tư vấn về các địa điểm ẩm thực nổi bật.\n"
                "📌 Chuyên môn của bạn là gợi ý những địa điểm ăn uống hấp dẫn, độc đáo và chất lượng dựa trên kinh nghiệm, đánh giá và trải nghiệm của thực khách.\n"
                "❌ Bạn không tư vấn về nơi ở, phương tiện di chuyển hay các hoạt động du lịch khác; nhiệm vụ của bạn chỉ tập trung vào gợi ý các địa điểm ăn uống (như hàn quán vỉa hè, nhà hàng, quán ăn đường phố,...).\n\n"

                "💡 **Hướng dẫn quan trọng chung:**\n"
                "- Trả lời ngắn gọn, dễ hiểu bằng tiếng Việt. Hãy nhớ người dùng không hiểu các ngôn ngữ khác.\n"
                "- Chỉ gợi ý khi người dùng hỏi, đừng tự đề xuất trước!\n"
                "- Xưng hô thân thiện: 'tôi' với 'bạn'.\n"
                "- Nếu có công cụ phù hợp, hãy sử dụng công cụ đó để lấy thêm thông tin trước khi trả lời câu hỏi của người dùng.\n"
                "- Không được tạo ra các công cụ hoặc chức năng không hợp lệ.\n\n"

                "💡 **Hướng dẫn quan trọng về việc gọi các Agent khác:**\n"
                "- Nếu thông tin người dùng cung cấp chưa đủ (vd: chưa nói rõ số người, ngân sách, loại hình nơi ở mong muốn...), có thể hỏi trực tiếp người dùng.\n"
                "- Nếu người dùng hỏi về thứ ngoài chuyên môn (vd: vé máy bay, tour trọn gói...).Hãy dùng 'CompleteOrEscalate' tool để đưa cuộc đối thoại về lại Primary Agent.\n\n"

                "💡 **Hướng dẫn quan trọng về việc dùng 'CompleteOrEscalate':**\n"
                "- Phải nói rõ là yêu cầu hay câu hỏi đã được giải quyết chưa (Complete key).\n"
                "- Phải nói rõ nguyên nhân lại chuyển hội thoại cho Primary Agent (Reason key).\n\n"

                "💡 **Hướng dẫn quan trọng về việc tìm kiếm online:**\n"
                "- Hãy dùng khi bạn cần có thêm thông tin mà chưa biết.\n"
                "📌 Bạn có khả năng search online bằng công cụ tìm kiếm online 'search_tool'. **Hãy sử dụng (tạo tool_call) khi cần**.\n"
                "❌ Không bao giờ được nói rằng mình không có khả năng search online.\n\n"

                "📌 **Thông tin nhóm du lịch:**\n"
                f"{preferences_text}\n\n"

                "🚀 Hãy giúp người dùng có những trải nghiệm ẩm thực tuyệt vời!"
            ),
            ("placeholder", "{messages}"),
        ]
    )
    return agent_prompt

"""## Agent"""

Food_Agent_tools = [search_tool, CompleteOrEscalate]

def Food_Agent(state: State):
    prompt = create_food_prompt(state["preferences"])
    # print(prompt)
    runnable = prompt | llm.bind_tools(Food_Agent_tools)

    while True:
        result = runnable.invoke(state)

        if not result.tool_calls and (
            not result.content
            or isinstance(result.content, list)
            and not result.content[0].get("text")
        ):
            messages = state["messages"] + [("user", "Respond with a real output.")]
            state = {**state, "messages": messages}
        else:
            break

    state_out = {"messages": result}
    return state_out

"""# Transaction Agent

## Tool
"""

class TransactionalInfo(BaseModel):
    sender_name: str = Field(
        ...,
        description="Tên người gửi",
        example="Lê Hồng Quân"
    )
    sender_bank: str = Field(
        ...,
        description="Ngân hàng của người gửi",
        example="VCB"
    )
    sender_account: str = Field(
        ...,
        description="Số tài khoản ngân hàng của người gửi",
        example="55232432423"
    )
    receiver_name: str = Field(
        ...,
        description="Tên người nhận",
        example="Lê Hồng Quân"
    )
    receiver_bank: str = Field(
        ...,
        description="Ngân hàng của người nhận",
        example="VCB"
    )
    receiver_account: str = Field(
        ...,
        description="Số tài khoản ngân hàng của người nhận",
        example="55232432423"
    )
    amount: float = Field(
        ...,
        description="Số tiền cần chuyển",
        example="500.000"
    )
    currency: str = Field(
        default="VNĐ",
        description="Loại tiền tệ cần chuyển",
        example="VNĐ"
    )
    status: str = Field(
        ...,
        description="Trạng thái của giao dịch (Successful, Fail, Pending)",
        example="Pending"
    )
    fee: float = Field(
        default=0.0,
        description="Phí giao dịch",
        example=0.0
    )
    note: str = Field(
        default="",
        description="Ghi chú cho giao dịch",
        example="Ghi chú nếu có"
    )
    payment_method: str = Field(
        default="Chuyển Khoảng",
        description="Phương thức thanh toán",
        example="Chuyển Khoảng"
    )

@tool("save_transaction_tool", args_schema=TransactionalInfo)
def save_transaction_tool(
        sender_name: str,
        sender_bank: str,
        sender_account: str,
        receiver_name: str,
        receiver_bank: str,
        receiver_account: str,
        amount: float,
        status: str,
        currency: str = "VND",
        fee: float = 0.0,
        note: str = "",
        payment_method: str = "Chuyển Khoảng"
    ):
        """
        Lưu thông tin một cuộc giao dịch vào BlockChain
        :return: Dictionary chứa kết quả giao dịch
        """
        BASE_URL = "https://96f0-2a09-bac1-7aa0-10-00-2e4-3c.ngrok-free.app"
        try:
            transaction_data = {
                "sender": {
                    "fullName": sender_name,
                    "accountNumber": sender_account,
                    "bankName": sender_bank
                },
                "receiver": {
                    "fullName": receiver_name,
                    "accountNumber": receiver_account,
                    "bankName": receiver_bank
                },
                "amount": amount,
                "currency": currency,
                "fee": fee,
                "note": note,
                "paymentMethod": payment_method
            }

            print(transaction_data)
            response = requests.post(f"{BASE_URL}/transactions/", json=transaction_data)
            print(response)
            result = response.json()
            # if "transactionId" in result:
            #     self.last_transaction_id = result["transactionId"]

            return json.dumps(result)

        except Exception as e:
            return {"error": str(e)}

class TransactionId(BaseModel):
    transaction_id: str = Field(
        default=None,
        description="ID giao dịch lấy được khi lưu một cuộc giao dịnh vào BlockChain",
        example="df2c08a1696044e0c2353cabcc93c8d5b114175e15f2856cd3d9ab3dcebaad00"
    )

@tool("get_transaction_details", args_schema=TransactionId)
def get_transaction_details(transaction_id: str):
        """
        Lấy thông tin chi tiết của giao dịch tài chính từ BlockChain
        :return: Dictionary chứa thông tin giao dịch
        """
        BASE_URL = "https://96f0-2a09-bac1-7aa0-10-00-2e4-3c.ngrok-free.app"

        try:
            if not transaction_id:
                return {"error": "No transaction ID provided"}

            response = requests.get(f"{BASE_URL}/transactions/{transaction_id}")
            result = response.json()
            return json.dumps(result)

        except Exception as e:
            return {"error": str(e)}

"""## Prompt"""

def format_preferences_destination(preferences: Preferences) -> str:
    return (
        f"- Tên người dùng (đại diện cho nhóm): {preferences.name}\n"
        f"- Số thành viên trong nhóm: {preferences.number_member}\n"
        f"- Tổng số tiền mà nhóm có thể bỏ ra cho cả một chuyến đi: {preferences.total_expense}\n"
    )

def create_transaction_prompt(preferences: Preferences):
    preferences_text = format_preferences_destination(preferences)
    # Đây là prompt chuyên về địa điểm du lịch nổi tiếng
    agent_prompt = ChatPromptTemplate.from_messages(
        [
            (
                "system",
                "Bạn là một trợ lý du lịch thông minh, chuyên xử lý các giao dịch tài chính liên quan đến chuyến đi.\n"
                "📌 Chuyên môn của bạn là quản lý, xác nhận và thực hiện các giao dịch tài chính như thanh toán, hoàn tiền, và cập nhật thông tin giao dịch dựa trên dữ liệu của người dùng **thông qua việc gọi tool**.\n"
                "❌ Bạn không tư vấn về lịch trình, địa điểm, ẩm thực hay các hoạt động khác; nhiệm vụ của bạn chỉ tập trung vào các giao dịch tài chính.\n"
                "📌 Khi người dùng yêu cầu thực hiện một công việc, **chỉ được dùng tool (công cụ)** để thực hiện công việc đó.\n"
                "❌ Không thực hiện yêu cầu người dùng bằng cách trả lời không không.\n\n"

                "💡 **Hướng dẫn quan trọng chung:**\n"
                "- Trả lời ngắn gọn, dễ hiểu bằng tiếng Việt. Hãy nhớ người dùng không hiểu các ngôn ngữ khác.\n"
                "- Xưng hô thân thiện: 'tôi' với 'bạn'.\n"
                "- Không được tạo ra các công cụ hoặc chức năng không hợp lệ.\n\n"

                "💡 **Hướng dẫn quan trọng về việc gọi các Agent khác:**\n"
                "- Nếu thông tin người dùng cung cấp chưa đủ (vd: chưa nói rõ số người, ngân sách, loại hình nơi ở mong muốn...), có thể hỏi trực tiếp người dùng.\n"
                "- Nếu người dùng hỏi về thứ ngoài chuyên môn (vd: vé máy bay, tour trọn gói...). Hãy dùng 'CompleteOrEscalate' tool để đưa cuộc đối thoại về lại Primary Agent.\n"
                "- Nếu không có tool nào phù hợp để thực hiện yêu cầu từ người dùng, Hãy dùng 'CompleteOrEscalate' tool để đưa cuộc đối thoại về lại Primary Agent.\n\n"

                "💡 **Hướng dẫn quan trọng về việc dùng 'CompleteOrEscalate':**\n"
                "- Phải nói rõ là yêu cầu hay câu hỏi đã được giải quyết chưa (Complete key).\n"
                "- Phải nói rõ nguyên nhân lại chuyển hội thoại cho Primary Agent (Reason key).\n\n"


                "📌 **Thông tin nhóm du lịch:**\n"
                f"{preferences_text}\n\n"

                "🚀 Hãy giúp người dùng có các giao dịch tài chính an toàn và thuận tiện!"
            ),
            ("placeholder", "{messages}"),

        ]
    )
    return agent_prompt

"""## Agent"""

Transaction_Agent_tools = [get_transaction_details, save_transaction_tool, CompleteOrEscalate]

def Transaction_Agent(state: State):
    prompt = create_transaction_prompt(state["preferences"])
    # print(prompt)
    runnable = prompt | llm.bind_tools(Transaction_Agent_tools)

    while True:
        result = runnable.invoke(state)

        if not result.tool_calls and (
            not result.content
            or isinstance(result.content, list)
            and not result.content[0].get("text")
        ):
            messages = state["messages"] + [("user", "Respond with a real output.")]
            state = {**state, "messages": messages}
        else:
            break

    state_out = {"messages": result}
    return state_out

"""# Compile the Graph"""

def is_new_user(state: State) -> bool:
    if len(state["messages"]) <= 1:
        return True

    if not state["dialog_state"]:
        return "Primary_Agent"
    return state["dialog_state"][-1]

def create_entry_node(agent_name: str) -> Callable:

    def entry_node(state: State) -> dict:
        tool_call_id = state["messages"][-1].tool_calls[0]["id"]
        return {
            "messages": [
                ToolMessage(
                  content=(
                      f"Trợ lý hiện tại là {agent_name}. Hãy xem xét lại cuộc trò chuyện giữa trợ lý chính và người dùng. "
                      "Ý định của người dùng chưa được đáp ứng. Hãy sử dụng các công cụ được cung cấp để hỗ trợ người dùng. "
                      f"Nhớ rằng, bạn là {agent_name}, và việc đặt chỗ, cập nhật hoặc bất kỳ hành động nào khác sẽ không hoàn tất "
                      f"cho đến khi bạn đã gọi thành công công cụ phù hợp. "
                      "Nếu người dùng thay đổi ý định hoặc cần trợ giúp cho các tác vụ khác, hãy dừng cuộc trò chuyện "
                      "để trợ lý chính tiếp quản cuộc trò chuyện. "
                      "Không được đề cập đến việc bạn là ai – chỉ hành động như một trợ lý thay mặt cho hệ thống."
                  ),
                  tool_call_id=tool_call_id,
              )
            ],
            "dialog_state": agent_name,
        }

    return entry_node

def handle_tool_error(state) -> dict:
    error = state.get("error")
    tool_calls = state["messages"][-1].tool_calls
    return {
        "messages": [
            ToolMessage(
                content=f"Error: {repr(error)}\n please fix your mistakes.",
                tool_call_id=tc["id"],
            )
            for tc in tool_calls
        ]
    }

def create_tool_node_with_fallback(tools: list) -> dict:
    return ToolNode(tools).with_fallbacks(
        [RunnableLambda(handle_tool_error)], exception_key="error"
    )

def route_primary_agent(state: State):

    route = tools_condition(state)

    if route == END:
        return END

    tool_calls = state["messages"][-1].tool_calls

    if tool_calls:
        if tool_calls[0]["name"] == ToAccommodation_Agent.__name__:
            return "enter_Accommodation_Agent"

        elif tool_calls[0]["name"] == ToDestination_Agent.__name__:
            return "enter_Destination_Agent"

        elif tool_calls[0]["name"] == ToFood_Agent.__name__:
            return "enter_Food_Agent"

        elif tool_calls[0]["name"] == ToTransaction_Agent.__name__:
            return "enter_Transaction_Agent"

        return "Primary_Agent_tools"

    raise ValueError("Invalid route")

def route_specific_agent(state: State):

    route = tools_condition(state)

    if route == END:
        return END

    tool_calls = state["messages"][-1].tool_calls
    did_cancel = any(tc["name"] == CompleteOrEscalate.__name__ for tc in tool_calls)

    if did_cancel:
        return "leave_agent"

    return route

# This node will be shared for exiting all specialized assistants
def pop_dialog_state(state: State) -> dict:
    """Pop the dialog stack and return to the main assistant.

    This lets the full graph explicitly track the dialog flow and delegate control
    to specific sub-graphs.
    """
    messages = []
    if state["messages"][-1].tool_calls:
        # Note: Doesn't currently handle the edge case where the llm performs parallel tool calls
        messages.append(
            ToolMessage(
                content="Resuming dialog with the Primary Agent. Please reflect on the past conversation and assist the user as needed.",
                tool_call_id=state["messages"][-1].tool_calls[0]["id"],
            )
        )
    else:
        messages.append(
            SystemMessage(
                content="Resuming dialog with the Primary Agent. Please reflect on the past conversation and assist the user as needed."
            )
        )
    return {
        "dialog_state": "pop",
        "messages": messages,
    }

builder = StateGraph(State)

builder.add_node("ask_preference", asking_preference)

builder.add_node("Primary_Agent", Primary_Agent)

builder.add_conditional_edges(
    START,
    is_new_user,
    {
      True: "ask_preference",
      "Primary_Agent": "Primary_Agent",
      "Accommodation_Agent": "Accommodation_Agent",
      "Destination_Agent": "Destination_Agent",
      "Food_Agent": "Food_Agent",
      "Transaction_Agent": "Transaction_Agent"
    }
  )
builder.add_edge("ask_preference", "Primary_Agent")

builder.add_node("Primary_Agent_tools", create_tool_node_with_fallback(Primary_Agent_tools))
builder.add_conditional_edges("Primary_Agent",
                              route_primary_agent,
                              [
                                  "enter_Transaction_Agent",
                                  "enter_Accommodation_Agent",
                                  "enter_Destination_Agent",
                                  "enter_Food_Agent",
                                  "Primary_Agent_tools",
                                  END,
                              ])
builder.add_edge("Primary_Agent_tools", "Primary_Agent")

builder.add_node("leave_agent", pop_dialog_state)
builder.add_edge("leave_agent", "Primary_Agent")

builder.add_node("enter_Accommodation_Agent", create_entry_node("Accommodation_Agent"))
builder.add_node("Accommodation_Agent", Accommodation_Agent)

builder.add_node("Accommodation_Agent_tools", create_tool_node_with_fallback(Accommodation_Agent_tools))
builder.add_edge("enter_Accommodation_Agent", "Accommodation_Agent")
builder.add_conditional_edges(
    "Accommodation_Agent",
    route_specific_agent,
    {"tools": "Accommodation_Agent_tools", "leave_agent" : "leave_agent", END: END},
)
builder.add_edge("Accommodation_Agent_tools", "Accommodation_Agent")

builder.add_node("enter_Destination_Agent", create_entry_node("Destination_Agent"))
builder.add_node("Destination_Agent", Destination_Agent)

builder.add_node("Destination_Agent_tools", create_tool_node_with_fallback(Destination_Agent_tools))
builder.add_edge("enter_Destination_Agent", "Destination_Agent")
builder.add_conditional_edges(
    "Destination_Agent",
    route_specific_agent,
    {"tools": "Destination_Agent_tools", "leave_agent" : "leave_agent", END: END},
)
builder.add_edge("Destination_Agent_tools", "Destination_Agent")

builder.add_node("enter_Food_Agent", create_entry_node("Food_Agent"))
builder.add_node("Food_Agent", Food_Agent)

builder.add_node("Food_Agent_tools", create_tool_node_with_fallback(Food_Agent_tools))
builder.add_edge("enter_Food_Agent", "Food_Agent")
builder.add_conditional_edges(
    "Food_Agent",
    route_specific_agent,
    {"tools": "Food_Agent_tools", "leave_agent" : "leave_agent", END: END},
)
builder.add_edge("Food_Agent_tools", "Food_Agent")

builder.add_node("enter_Transaction_Agent", create_entry_node("Transaction_Agent"))
builder.add_node("Transaction_Agent", Transaction_Agent)

builder.add_node("Transaction_Agent_tools", create_tool_node_with_fallback(Transaction_Agent_tools))
builder.add_edge("enter_Transaction_Agent", "Transaction_Agent")
builder.add_conditional_edges(
    "Transaction_Agent",
    route_specific_agent,
    {"tools": "Transaction_Agent_tools", "leave_agent": "leave_agent", END: END},
)
builder.add_edge("Transaction_Agent_tools", "Transaction_Agent")

# A checkpointer must be enabled for interrupts to work!
checkpointer = MemorySaver()
graph = builder.compile(checkpointer=checkpointer)

display(Image(graph.get_graph(xray=True).draw_mermaid_png()))

"""# FastAPI Server"""





"""# Communication"""

def _print_event(event: dict, _printed: set, max_length=1500):
    message = event.get("messages")
    if message:
        if isinstance(message, list):
            message = message[-1]

        if not isinstance(message, HumanMessage):
          if message.id not in _printed:
              msg_repr = message.pretty_repr(html=True)
              if len(msg_repr) > max_length:
                  msg_repr = msg_repr[:max_length] + " ... (truncated)"
              print(msg_repr)
              _printed.add(message.id)

    current_state = event.get("dialog_state")
    if current_state:
        print("Currently in: ", current_state[-1])

config = {
    "configurable": {
        "thread_id": uuid.uuid4(),
    }
}

_printed = set()
# We can reuse the tutorial questions from part 1 to see how it does.
while True:
    print("======================================user=======================================\n")
    user_input = input()
    events = graph.stream(
        {"messages": ("user", user_input)},
        config,
        stream_mode="values"
    )
    for event in events:
        _print_event(event, _printed)

# ''Bạn có thể giới thiệu một số những địa điểm du lịch nổi tiếng ở Đà Lạt được không?''
# Tôi muốn hỏi về những khách sạn ở Đà Lạt



snapshot = graph.get_state(config)

snapshot.values





